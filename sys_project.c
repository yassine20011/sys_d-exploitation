#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define RED "\033[31m"
#define GREEN "\033[32m"
#define YELLOW "\033[4;33m"
#define BLUE "\033[34m"
#define RESET "\033[0m"

int *copyMemory(const int *memoryShap, int memorySize)
{
    int *result = (int *)malloc(memorySize * sizeof(int));
    for (int i = 0; i < memorySize; i++)
        result[i] = memoryShap[i];
    return result;
}

int getListsOfFreeSpaces(const int *memoryShap, int *listOfFreeSpaces, int memorySize)
{
    int count, k = 0, j, i;
    for (i = 0; i < memorySize; i++)
    {
        if (memoryShap[i] == 0)
        {
            count = 0;
            for (j = i; j < memorySize; j++)
            {
                if (memoryShap[j] == 0)
                    count++;
                else
                    break;
            }

            listOfFreeSpaces[k] = count;
            k++;
            i = j;
        }
    }
    return k;
}

int *first_fit(const int *memoryShap, int newProcessSize, int memorySize)
{
    int count, done = 0;
    int *result = copyMemory(memoryShap, memorySize);

    if (newProcessSize == 0)
    {
        return result;
    }

    for (int i = 0; i < memorySize; i++)
    {
        if (result[i] == 0)
        {
            count = 0;
            for (int j = i; j < memorySize; j++)
            {
                if (result[j] == 0)
                    count++;
                else
                    break;
            }

            if (count >= newProcessSize)
            {
                for (int j = i; j < i + newProcessSize; j++)
                {
                    result[j] = 1;
                    done = 1;
                }
                break;
            }
        }
    }

    if (!done)
        return NULL;

    return result;
}

int *next_fit(const int *memoryShap, int newProcessSize, int memorySize)
{

    int j, count, done = 0;
    int *result = copyMemory(memoryShap, memorySize);
    int *listOfFreeSpaces = (int *)malloc(10 * sizeof(int));
    count = getListsOfFreeSpaces(memoryShap, listOfFreeSpaces, memorySize);

    // check if the memory is full
    for (int i = 0; i < count; i++)
    {
        if (listOfFreeSpaces[i] >= newProcessSize)
        {
            done = 1;
            break;
        }
    }

    if (!done)
        return NULL;

    for (int i = 0; i < memorySize; i++)
    {
        if (result[i])
            j = i;
    }

    for (int i = j; i <= newProcessSize + j; i++)
    {
        result[i] = 1;
    }

    if (listOfFreeSpaces[count - 1] < newProcessSize)
    {
        return NULL;
    }

    return result;
}

int *best_fit(const int *memoryShap, int newProcessSize, int memorySize)
{
    int *result = copyMemory(memoryShap, memorySize);
    int done = 0, count, k = 0, j, i;
    int *listOfFreeSpaces = (int *)malloc(10 * sizeof(int));
    k = getListsOfFreeSpaces(memoryShap, listOfFreeSpaces, memorySize);

    // check if the memory is full
    int min = 1000;
    int index = -1;
    for (int i = 0; i < k; i++)
    {
        if (listOfFreeSpaces[i] >= newProcessSize && listOfFreeSpaces[i] < min)
        {
            min = listOfFreeSpaces[i];
            index = i;
            done = 1;
        }
    }

    if (!done)
        return NULL;

    for (i = 0; i < memorySize; i++)
    {
        if (result[i] == 0)
        {
            count = 0;
            for (j = i; j < memorySize; j++)
            {
                if (!result[j]) // if the block is free which means it's equal to 0
                    count++;
                else
                    break;
            }

            if (count == min)
            {
                for (int j = i; j < i + newProcessSize; j++)
                {
                    result[j] = 1;
                }
                break;
            }
            i = j; // skip the occupied blocks
        }
    }

    return result;
}

int *worse_fit(const int *memoryShap, int newProcessSize, int memorySize)
{
    int *result = copyMemory(memoryShap, memorySize);
    int done = 0, count, k, j, i;
    int *listOfFreeSpaces = (int *)malloc(10 * sizeof(int));
    k = getListsOfFreeSpaces(memoryShap, listOfFreeSpaces, memorySize);

    // check if the memory is full
    for (int i = 0; i < k; i++)
    {
        if (listOfFreeSpaces[i] >= newProcessSize)
        {
            done = 1;
            break;
        }
    }
    if (!done)
        return NULL;

    int max = listOfFreeSpaces[0];
    int index = 0;
    for (int i = 1; i < k; i++)
    {
        if (listOfFreeSpaces[i] > max)
        {
            max = listOfFreeSpaces[i];
            index = i;
        }
    }

    for (i = 0; i < memorySize; i++)
    {
        if (result[i] == 0)
        {
            count = 0;
            for (j = i; j < memorySize; j++)
            {
                if (result[j] == 0)
                    count++;
                else
                    break;
            }

            if (count == max)
            {
                for (int j = i; j < i + newProcessSize; j++)
                {
                    result[j] = 1;
                }
                break;
            }
            i = j;
        }
    }

    return result;
}

void showMemory(int *memory, const int *initialMemoryShape, char *algorithmName, int memorySize)
{

    for (int i = 0; i < memorySize; i++)
    {
        if (memory[i] != initialMemoryShape[i])
            printf("|%2d%s*%s", memory[i], RED, RESET);
        else if (memory[i] == 1)
            printf("|%s%2d%s ", GREEN, memory[i], RESET);
        else
            printf("|%2d ", memory[i]);
    }
    printf("|| ||=> %-15s|\n", algorithmName);
}

int main()
{
    int memorySize;
    do
    {
        printf("%sEnter memory size 8, 16, 32, 64, 128, 256, 512, 1024: %s", YELLOW, RESET);
        scanf("%d", &memorySize);
    } while (memorySize != 8 && memorySize != 16 && memorySize != 32 && memorySize != 64 && memorySize != 128 && memorySize != 256 && memorySize != 512 && memorySize != 1024);

    const int initialMemoryShape[memorySize];
    for (int i = 0; i < memorySize; i++)
    {

        do
        {
            printf("%sEnter memory block %d | 0(free) or 1(occupied): %s", YELLOW, i, RESET);
            scanf("%d", &initialMemoryShape[i]);
        } while (initialMemoryShape[i] != 0 && initialMemoryShape[i] != 1);
    }

    int processSize;

    do
    {

        printf("%sEnter process size: %s", YELLOW, RESET);
        scanf("%d", &processSize);
        printf("\n");
        printf("%s - Initial Memory Shape %s\n", BLUE, RESET);
        for (int i = 0; i < memorySize; i++)
        {
            printf("|%2d ", i);
        }
        printf("|\n");

        for (int i = 0; i < memorySize; i++)
        {
            if (initialMemoryShape[i] == 1)
                printf("|%2d\033[31m*\033[0m", initialMemoryShape[i]);
            else
                printf("|%2d ", initialMemoryShape[i]);
        }
        printf("|\n\n");

        printf("|--- %sMemory Blocks%s --------------------------------------------------------------------|\n", BLUE, RESET);
        for (int i = 0; i < memorySize; i++)
        {
            printf("|%2d ", i);
        }
        printf("|| ||=> Algorithm Name |\n");

        int *memory = first_fit(initialMemoryShape, processSize, memorySize);
        memory == NULL ? printf("|%sMemory is Full%s\n", RED, RESET) : showMemory(memory, initialMemoryShape, "First Fit", memorySize);

        memory = next_fit(initialMemoryShape, processSize, memorySize);
        memory == NULL ? printf("|%sMemory is Full%s\n", RED, RESET) : showMemory(memory, initialMemoryShape, "Next Fit", memorySize);

        memory = best_fit(initialMemoryShape, processSize, memorySize);
        memory == NULL ? printf("|%sMemory is Full%s\n", RED, RESET) : showMemory(memory, initialMemoryShape, "Best Fit", memorySize);

        memory = worse_fit(initialMemoryShape, processSize, memorySize);
        memory == NULL ? printf("|%sMemory is Full%s\n", RED, RESET) : showMemory(memory, initialMemoryShape, "Worse Fit", memorySize);

        printf("|--------------------------------------------------------------------------------------|\n");
        printf("\n");

        printf("%sNote: %s\n", YELLOW, RESET);
        printf("%s1. %sMemory is divided into 16 blocks.\n", GREEN, RESET);
        printf("%s2. %sMemory blocks are represented by numbers from 0 to 15.\n", GREEN, RESET);
        printf("%s3. %sMemory blocks with '*' are the ones that are occupied by the new process.\n", GREEN, RESET);
        printf("%s4. %sMemory blocks without '*' are the ones that are free.\n", GREEN, RESET);
        printf("%s5. %s 0 means free, 1 means occupied.\n", GREEN, RESET);

        free(memory);

    } while (1);
    return 0;
}